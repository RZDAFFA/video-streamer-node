const express = require('express');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const { spawn, exec } = require('child_process');
const cors = require('cors');
const { v4: uuidv4 } = require('uuid');

const app = express();
const PORT = 9001;

// Middleware
app.use(cors());
app.use(express.json({ limit: '500mb' }));
app.use(express.urlencoded({ extended: true, limit: '500mb' }));

// Configuration
const config = {
    uploadFolder: 'uploads',
    outputFolder: 'output',
    maxFileSize: 500 * 1024 * 1024, // 500MB
    allowedExtensions: ['.mp4', '.avi', '.mov', '.mkv', '.webm'],
    hlsTime: 6,          // 6 second segments
    hlsListSize: 8,      // Keep 8 segments
    maxConcurrentStreams: 10  // Increased to 10 concurrent streams
};

// Create directories
if (!fs.existsSync(config.uploadFolder)) {
    fs.mkdirSync(config.uploadFolder, { recursive: true });
}
if (!fs.existsSync(config.outputFolder)) {
    fs.mkdirSync(config.outputFolder, { recursive: true });
}

// Store active streams
let activeStreams = {};

// Configure multer for file upload
const storage = multer.diskStorage({
    destination: (req, file, cb) => {
        cb(null, config.uploadFolder);
    },
    filename: (req, file, cb) => {
        const streamId = req.body.name + '_' + uuidv4().substring(0, 8);
        const sanitizedName = file.originalname.replace(/[<>:"/\\|?*]/g, '_');
        cb(null, `${streamId}_${sanitizedName}`);
    }
});

const upload = multer({ 
    storage: storage,
    limits: { fileSize: config.maxFileSize },
    fileFilter: (req, file, cb) => {
        const ext = path.extname(file.originalname).toLowerCase();
        if (config.allowedExtensions.includes(ext)) {
            cb(null, true);
        } else {
            cb(new Error('Invalid file type'), false);
        }
    }
});

// Utility functions
function sanitizeFilename(filename) {
    return filename.replace(/[<>:"/\\|?*]/g, '_').substring(0, 100);
}

function startFFmpegStream(inputPath, outputPath) {
    const cmd = [
        '-y',
        '-stream_loop', '-1',
        '-i', inputPath,
        '-c:v', 'libx264',
        '-preset', 'ultrafast',  // Ultra fast encoding for 10 streams
        '-tune', 'zerolatency',  // Optimize for low latency
        '-crf', '28',            // Lower quality for more streams
        '-maxrate', '1500k',     // Reduced bitrate for 10 streams
        '-bufsize', '3000k',     // Smaller buffer for efficiency
        '-vf', 'scale=1920:1080:force_original_aspect_ratio=decrease,fps=24',  // 1080p @ 24fps
        '-g', '48',              // GOP size (2 seconds at 24fps)
        '-sc_threshold', '0',    // Disable scene change detection
        '-threads', '2',         // Reduced threads for 10 streams
        '-c:a', 'aac',
        '-b:a', '96k',           // Reduced audio bitrate
        '-ac', '2',              // Stereo audio
        '-ar', '44100',          // Standard sample rate
        '-f', 'hls',
        '-hls_time', config.hlsTime.toString(),
        '-hls_list_size', config.hlsListSize.toString(),
        '-hls_flags', 'delete_segments+append_list+independent_segments',
        '-hls_segment_type', 'mpegts',
        '-hls_playlist_type', 'event',
        '-hls_segment_filename', path.join(outputPath, 'segment_%05d.ts'),
        path.join(outputPath, 'index.m3u8')
    ];

    console.log('Starting FFmpeg with 10-stream optimization:', cmd.join(' '));
    
    // Set process priority to lower CPU usage
    const process = spawn('ffmpeg', cmd, {
        stdio: ['ignore', 'pipe', 'pipe']
    });
    
    // Lower process priority for multiple streams
    if (process.pid) {
        try {
            require('child_process').exec(`renice +10 ${process.pid}`);  // Higher nice for 10 streams
        } catch (err) {
            console.log('Could not set process priority:', err.message);
        }
    }
    
    return process;
}

function cleanupInputFile(filePath) {
    setTimeout(() => {
        if (fs.existsSync(filePath)) {
            fs.unlinkSync(filePath);
            console.log(`Cleaned up input file: ${filePath}`);
        }
    }, 300000); // 5 minutes
}

// Routes
app.get('/', (req, res) => {
    res.send(`
    <!DOCTYPE html>
    <html>
    <head>
        <title>Video Loop Streamer Control Panel</title>
        <style>
            body {
                font-family: Arial, sans-serif;
                max-width: 900px;
                margin: 20px auto;
                padding: 20px;
                background: #f5f5f5;
            }
            .container {
                background: white;
                padding: 20px;
                border-radius: 8px;
                box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                margin-bottom: 20px;
            }
            h1 { color: #333; text-align: center; }
            h2 { color: #666; border-bottom: 2px solid #007bff; padding-bottom: 10px; }
            .form-group { margin: 15px 0; }
            label { display: block; margin-bottom: 5px; font-weight: bold; }
            input[type="text"], input[type="file"] {
                width: 100%;
                padding: 10px;
                border: 1px solid #ddd;
                border-radius: 4px;
                box-sizing: border-box;
            }
            .btn {
                padding: 10px 15px;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-size: 14px;
                margin: 5px;
            }
            .btn-primary { background: #007bff; color: white; }
            .btn-danger { background: #dc3545; color: white; }
            .btn-success { background: #28a745; color: white; }
            .btn:hover { opacity: 0.8; }
            .stream-item {
                background: #f8f9fa;
                padding: 15px;
                margin: 10px 0;
                border-radius: 4px;
                border: 1px solid #dee2e6;
                border-left: 4px solid #28a745;
            }
            .stream-url {
                background: #e9ecef;
                padding: 8px;
                border-radius: 3px;
                font-family: monospace;
                font-size: 12px;
                word-break: break-all;
                margin: 5px 0;
            }
            .status { 
                margin-top: 20px; 
                padding: 10px; 
                border-radius: 4px; 
                display: none;
            }
            .status.success { background: #d4edda; border: 1px solid #c3e6cb; color: #155724; }
            .status.error { background: #f8d7da; border: 1px solid #f5c6cb; color: #721c24; }
        </style>
    </head>
    <body>
        <h1>üé• Video Loop Streamer Control Panel</h1>
        <div class="container">
            <h2>üì§ Upload New Video</h2>
            <form id="uploadForm" enctype="multipart/form-data">
                <div class="form-group">
                    <label for="name">Stream Name:</label>
                    <input type="text" name="name" id="name" required placeholder="Enter stream name">
                </div>
                <div class="form-group">
                    <label for="file">Select Video:</label>
                    <input type="file" name="file" id="file" accept="video/*" required>
                </div>
                <button type="submit" class="btn btn-primary">üì§ Upload and Start Stream</button>
            </form>
        </div>
        
        <div class="container">
            <h2>üéõÔ∏è Stream Control Panel</h2>
            <button onclick="refreshStreams()" class="btn btn-primary">üîÑ Refresh Stream List</button>
            <button onclick="stopAllStreams()" class="btn btn-danger">‚èπÔ∏è Stop All Streams</button>
            <button onclick="cleanupAll()" class="btn btn-danger">üßπ Cleanup All</button>
        </div>
        
        <div class="container">
            <h2>üì° Active Streams</h2>
            <div id="streamsList">
                <div id="noStreams" style="text-align: center; color: #666; padding: 20px;">
                    No active streams found
                </div>
            </div>
        </div>
        
        <div id="status" class="status"></div>
        
        <script>
            function showStatus(message, type = 'success') {
                const statusDiv = document.getElementById('status');
                statusDiv.className = 'status ' + type;
                statusDiv.textContent = message;
                statusDiv.style.display = 'block';
                setTimeout(() => statusDiv.style.display = 'none', 5000);
            }
            
            async function refreshStreams() {
                try {
                    const response = await fetch('/streams');
                    const streams = await response.json();
                    displayStreams(streams);
                } catch (error) {
                    showStatus('Failed to load streams: ' + error.message, 'error');
                }
            }
            
            function displayStreams(streams) {
                const container = document.getElementById('streamsList');
                const noStreamsDiv = document.getElementById('noStreams');
                
                if (Object.keys(streams).length === 0) {
                    noStreamsDiv.style.display = 'block';
                    container.innerHTML = '<div id="noStreams" style="text-align: center; color: #666; padding: 20px;">No active streams found</div>';
                    return;
                }
                
                let html = '';
                for (const [streamId, streamUrl] of Object.entries(streams)) {
                    html += \`
                        <div class="stream-item">
                            <h3>üü¢ \${streamId}</h3>
                            <div class="stream-url">
                                <strong>HLS:</strong> \${window.location.origin}\${streamUrl}
                            </div>
                            <div style="margin-top: 10px;">
                                <button onclick="copyStreamUrl('\${streamUrl}')" class="btn btn-success">üìã Copy URL</button>
                                <button onclick="testStream('\${streamUrl}')" class="btn btn-primary">‚ñ∂Ô∏è Test Stream</button>
                                <button onclick="stopStream('\${streamId}')" class="btn btn-danger">‚èπÔ∏è Stop Stream</button>
                            </div>
                        </div>
                    \`;
                }
                container.innerHTML = html;
            }
            
            function copyStreamUrl(url) {
                const fullUrl = window.location.origin + url;
                navigator.clipboard.writeText(fullUrl).then(() => {
                    showStatus('üìã Stream URL copied to clipboard!', 'success');
                });
            }
            
            function testStream(url) {
                window.open(window.location.origin + url, '_blank');
            }
            
            async function stopStream(streamId) {
                if (!confirm(\`Are you sure you want to stop stream: \${streamId}?\`)) return;
                try {
                    const response = await fetch(\`/streams/\${streamId}\`, { method: 'DELETE' });
                    if (response.ok) {
                        showStatus(\`‚úÖ Stream \${streamId} stopped successfully\`, 'success');
                        refreshStreams();
                    } else {
                        const error = await response.json();
                        showStatus(\`‚ùå Failed to stop stream: \${error.error}\`, 'error');
                    }
                } catch (error) {
                    showStatus(\`‚ùå Error stopping stream: \${error.message}\`, 'error');
                }
            }
            
            async function stopAllStreams() {
                if (!confirm('Are you sure you want to stop ALL streams?')) return;
                try {
                    const response = await fetch('/streams/all', { method: 'DELETE' });
                    if (response.ok) {
                        showStatus('‚úÖ All streams stopped successfully', 'success');
                        refreshStreams();
                    }
                } catch (error) {
                    showStatus(\`‚ùå Error stopping streams: \${error.message}\`, 'error');
                }
            }
            
            async function cleanupAll() {
                if (!confirm('Are you sure you want to cleanup all files?')) return;
                try {
                    const response = await fetch('/cleanup', { method: 'POST' });
                    if (response.ok) {
                        showStatus('‚úÖ Cleanup completed successfully', 'success');
                        refreshStreams();
                    }
                } catch (error) {
                    showStatus(\`‚ùå Error during cleanup: \${error.message}\`, 'error');
                }
            }
            
            document.getElementById('uploadForm').addEventListener('submit', async (e) => {
                e.preventDefault();
                const formData = new FormData(e.target);
                
                try {
                    const response = await fetch('/upload', {
                        method: 'POST',
                        body: formData
                    });
                    
                    if (response.ok) {
                        const result = await response.json();
                        showStatus(\`‚úÖ Stream started: \${result.stream_id}\`, 'success');
                        e.target.reset();
                        refreshStreams();
                    } else {
                        const error = await response.json();
                        showStatus(\`‚ùå Upload failed: \${error.error}\`, 'error');
                    }
                } catch (error) {
                    showStatus(\`‚ùå Upload error: \${error.message}\`, 'error');
                }
            });
            
            // Auto refresh streams
            refreshStreams();
            setInterval(refreshStreams, 30000);
        </script>
    </body>
    </html>
    `);
});

// Upload endpoint
app.post('/upload', upload.single('file'), (req, res) => {
    try {
        const { name } = req.body;
        const file = req.file;

        if (!name || !name.trim()) {
            return res.status(400).json({ error: 'Stream name cannot be empty' });
        }

        if (!file) {
            return res.status(400).json({ error: 'No file uploaded' });
        }

        // Check concurrent stream limit
        const activeStreamCount = Object.keys(activeStreams).length;
        if (activeStreamCount >= config.maxConcurrentStreams) {
            return res.status(429).json({ 
                error: `Maximum ${config.maxConcurrentStreams} concurrent streams allowed. Please stop a stream first.` 
            });
        }

        const streamId = `${sanitizeFilename(name)}_${uuidv4().substring(0, 8)}`;
        const inputPath = file.path;
        const outputPath = path.join(config.outputFolder, streamId);

        // Create output directory
        if (fs.existsSync(outputPath)) {
            fs.rmSync(outputPath, { recursive: true, force: true });
        }
        fs.mkdirSync(outputPath, { recursive: true });

        // Start FFmpeg process with CPU optimization
        const ffmpegProcess = startFFmpegStream(inputPath, outputPath);
        
        activeStreams[streamId] = {
            process: ffmpegProcess,
            outputPath: outputPath,
            inputPath: inputPath,
            startTime: Date.now()
        };

        ffmpegProcess.on('error', (error) => {
            console.error(`FFmpeg error for ${streamId}:`, error);
            delete activeStreams[streamId];
        });

        ffmpegProcess.on('exit', (code) => {
            console.log(`FFmpeg process for ${streamId} exited with code ${code}`);
            if (activeStreams[streamId]) {
                delete activeStreams[streamId];
            }
        });

        // Monitor CPU usage periodically
        const monitorInterval = setInterval(() => {
            if (!activeStreams[streamId]) {
                clearInterval(monitorInterval);
                return;
            }
            
            // Check if process is still running
            if (ffmpegProcess.killed || !ffmpegProcess.pid) {
                clearInterval(monitorInterval);
                delete activeStreams[streamId];
            }
        }, 30000); // Check every 30 seconds

        // Schedule cleanup of input file
        cleanupInputFile(inputPath);

        const streamUrl = `/output/${streamId}/index.m3u8`;
        console.log(`Stream started: ${streamId} (${activeStreamCount + 1}/${config.maxConcurrentStreams} active)`);

        res.json({
            stream_id: streamId,
            stream_url: streamUrl,
            status: 'streaming',
            active_streams: activeStreamCount + 1,
            max_streams: config.maxConcurrentStreams
        });

    } catch (error) {
        console.error('Error processing upload:', error);
        res.status(500).json({ error: 'Internal server error' });
    }
});

// Serve output files
app.use('/output', express.static(config.outputFolder, {
    setHeaders: (res) => {
        res.setHeader('Access-Control-Allow-Origin', '*');
        res.setHeader('Access-Control-Allow-Methods', 'GET');
    }
}));

// List streams endpoint
app.get('/streams', (req, res) => {
    const streams = {};
    for (const [streamId, data] of Object.entries(activeStreams)) {
        if (data.process && !data.process.killed) {
            streams[streamId] = `/output/${streamId}/index.m3u8`;
        }
    }
    res.json(streams);
});

// Stop specific stream
app.delete('/streams/:streamId', (req, res) => {
    const { streamId } = req.params;
    
    if (!activeStreams[streamId]) {
        return res.status(404).json({ error: 'Stream not found' });
    }

    const stream = activeStreams[streamId];
    
    // Kill FFmpeg process
    if (stream.process && !stream.process.killed) {
        stream.process.kill('SIGTERM');
        setTimeout(() => {
            if (!stream.process.killed) {
                stream.process.kill('SIGKILL');
            }
        }, 5000);
    }

    // Clean up output directory
    if (fs.existsSync(stream.outputPath)) {
        fs.rmSync(stream.outputPath, { recursive: true, force: true });
    }

    delete activeStreams[streamId];
    res.json({ message: `Stream ${streamId} stopped` });
});

// Stop all streams
app.delete('/streams/all', (req, res) => {
    const stoppedStreams = [];
    
    for (const [streamId, stream] of Object.entries(activeStreams)) {
        if (stream.process && !stream.process.killed) {
            stream.process.kill('SIGTERM');
            setTimeout(() => {
                if (!stream.process.killed) {
                    stream.process.kill('SIGKILL');
                }
            }, 5000);
        }
        
        if (fs.existsSync(stream.outputPath)) {
            fs.rmSync(stream.outputPath, { recursive: true, force: true });
        }
        
        stoppedStreams.push(streamId);
    }
    
    activeStreams = {};
    res.json({ 
        message: `Stopped ${stoppedStreams.length} streams`,
        stopped_streams: stoppedStreams 
    });
});

// Cleanup endpoint
app.post('/cleanup', (req, res) => {
    try {
        // Stop all streams first
        for (const [streamId, stream] of Object.entries(activeStreams)) {
            if (stream.process && !stream.process.killed) {
                stream.process.kill('SIGKILL');
            }
        }
        activeStreams = {};

        // Clean up upload files
        let uploadFilesRemoved = 0;
        if (fs.existsSync(config.uploadFolder)) {
            const files = fs.readdirSync(config.uploadFolder);
            files.forEach(file => {
                const filePath = path.join(config.uploadFolder, file);
                if (fs.lstatSync(filePath).isFile()) {
                    fs.unlinkSync(filePath);
                    uploadFilesRemoved++;
                }
            });
        }

        // Clean up output directories
        let outputDirsRemoved = 0;
        if (fs.existsSync(config.outputFolder)) {
            const dirs = fs.readdirSync(config.outputFolder);
            dirs.forEach(dir => {
                const dirPath = path.join(config.outputFolder, dir);
                if (fs.lstatSync(dirPath).isDirectory()) {
                    fs.rmSync(dirPath, { recursive: true, force: true });
                    outputDirsRemoved++;
                }
            });
        }

        const message = `Cleanup completed: ${uploadFilesRemoved} upload files and ${outputDirsRemoved} stream directories removed`;
        console.log(message);

        res.json({
            message: message,
            upload_files_removed: uploadFilesRemoved,
            stream_directories_removed: outputDirsRemoved
        });

    } catch (error) {
        console.error('Error during cleanup:', error);
        res.status(500).json({ error: `Cleanup failed: ${error.message}` });
    }
});

// Stream info endpoint
app.get('/streams/:streamId/info', (req, res) => {
    const { streamId } = req.params;
    
    if (!activeStreams[streamId]) {
        return res.status(404).json({ error: 'Stream not found' });
    }

    const stream = activeStreams[streamId];
    const isRunning = stream.process && !stream.process.killed;
    
    let segmentFiles = [];
    let playlistExists = false;
    
    if (fs.existsSync(stream.outputPath)) {
        const playlistPath = path.join(stream.outputPath, 'index.m3u8');
        playlistExists = fs.existsSync(playlistPath);
        
        const files = fs.readdirSync(stream.outputPath);
        segmentFiles = files
            .filter(file => file.endsWith('.ts'))
            .map(file => {
                const filePath = path.join(stream.outputPath, file);
                const stats = fs.statSync(filePath);
                return {
                    name: file,
                    size: stats.size,
                    created: stats.mtime.getTime()
                };
            });
    }

    res.json({
        stream_id: streamId,
        status: isRunning ? 'running' : 'stopped',
        process_id: stream.process ? stream.process.pid : null,
        playlist_exists: playlistExists,
        segment_count: segmentFiles.length,
        segments: segmentFiles,
        stream_url: playlistExists ? `/output/${streamId}/index.m3u8` : null
    });
});

// Start server
app.listen(PORT, '0.0.0.0', () => {
    console.log(`üé• Video Streaming Server running on http://0.0.0.0:${PORT}`);
    console.log(`üìÅ Upload folder: ${config.uploadFolder}`);
    console.log(`üìÅ Output folder: ${config.outputFolder}`);
    console.log(`üé¨ Supported formats: ${config.allowedExtensions.join(', ')}`);
});

// Graceful shutdown
process.on('SIGINT', () => {
    console.log('\nüõë Shutting down server...');
    
    // Stop all streams
    for (const [streamId, stream] of Object.entries(activeStreams)) {
        if (stream.process && !stream.process.killed) {
            console.log(`Stopping stream: ${streamId}`);
            stream.process.kill('SIGKILL');
        }
    }
    
    process.exit(0);
});

process.on('uncaughtException', (error) => {
    console.error('Uncaught Exception:', error);
});

process.on('unhandledRejection', (reason, promise) => {
    console.error('Unhandled Rejection at:', promise, 'reason:', reason);
});
